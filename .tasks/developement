



pt EDITmode.js

<input
data-iedit-btt = 'numeleButtonului'
data-iedit-elm = 'numele elementului de care apartine'
data-iedit-callback = true/ false
>

buunn...
EDsel

este o oarecare problema aici eu il vad in felul urmator

<div class = 'EDsel folder' data-iedit-options='$json'>

deci hai sa vedem ce am eu de facut
1. trebuie declarata o metoda care sa preaia aceste setari
2. 2 crearea jsonului de folders

3. mai intai vom lucra pe folders






7 august 2013

deci problema lui CsetModule este defapt ca baga css si js-ul inainte de
instantierea modulului
in Module Set
ar trebui sa existe Module_config si Module_inc or something
sau mai bine zis dupa apelarea metodei de _init_

core->jsTalk
refer
 - to EDITmode.js
 - core.yml
 - Ccore.php - variables

Cuser extends permissions
Cprofile extends Cuser
ACprofile extends Cprofile


Ccore
 - js can now send multiple methods to be called from the same handling parrent
 - * din pacate nu pate sa apeleze alt modul


31 iulie

EDITmode.js

- adaugare proprietate pentru etraButtons: methName
- adaugare extraHtml

- refactoring la modul de bindeuri pe methName
- adaugarea obiectului templates

30iulie


* observ niset probleme in CsetModule - Module_Build

deoarece se instantiaza intai modulul
partea de init vine mai apoi
dupa setarea lui
dar in setarea lui pote depinde de template file pentru aceasta setare

profile page
** campuri existente **
- first_name
- last_name
- title
- bio
- photo
- phone
- site

- email
** invizible **

- facilitati:
*suspend - campul active



16 iulie...
si cu toate astea....


15 iulie

- este atat de tarziu...

Cblog
CLblog extends Cblog
ACblog

13 iulie

 /**
 * Si aici avem mai multe optiuni / filre?
 * 1. din tot blogul / archive
 * 2. pe categorie in special din blog / archive
 * 3. alte filtre (ex: dupa tipul de record )
 */


filterName : category / via get
filterValue :

ex: Set_queryRecordsBy[filterName](filterValue = '')

se poate porni de la un query de baza si practic aceste filtre vor fi adaugiri
de wheruri


Deci aici cred ca trebuie facuta o logica generala...
ce inseamna filtru dupa categorie si dupa altele
+ dupa templating ( dar de unde stii ca mai ai nevoie si de templating)
Cautzi sa vezi daca exista metoda

Sa nu uitam ca un query ar putea sa aibe mai multe filtre
ex:
1. este din start category : idC
2. altul ar putea sa fie orice altceva...

Sa vedem ce notiuni am incorporat

### Proprietati :###

tmplFiles[$methodHandle]

$methodHandle = determinata de requesturi cum ar fii $_GET['idRec'] sau setari

$methodHandles[$idTree]


### Metode: ###

_handle_request()
    * SETS: methodHandle , template_file
    * CALL: [methodHandle]_setData








actiunile / dinamica siteului = defapt cu requesturile  siteului
deci daca ne dam seama clar de requesturile posibile in interiorul siteului
ne-am putea da seama foarte usor si de dinamica acestui
Asa ca hai sa schitzam niste requesturi

dar mai intai....

$idTree & $idNode
$idTree & $idNode & $idRec
$idTree & $idNode & $filterName = something1 & filervalue = something2

 s-ar putea sa putem trimite aceste filtre si print-un post ca sa trimitem mai multe
 dar asta ramane de vazut

cred ca trebuie sa ne gandim si la partea de ordonare


Cblog
CblogArchive extends Cblog

ACblog extends

ACblogArchive extends

CLblog
Cblog extends CLblog

type = blog.archive

settings : jSON:

=> Carchive

$this->opt->handler = home

Cblog
CLblog extends Cblog

ACblog extends CLblog
ACLblog extends ACblog